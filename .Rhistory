matrix(sample(1:100, 5, replace=T), nrow = 3, ncol = 3)
length(mat)
mat<- matrix(sample(1:100, 5, replace=T), nrow = 3, ncol = 3)
length(mat)
length(mat)*0.2
round(length(mat)*0.2)
omitNr<-round(length(mat)*0.2)
mat<- matrix(sample(1:100, 5, replace=T), nrow = 3, ncol = 3)
mat
omitNr<-round(length(mat)*0.2)
mat[sample(omitNr)]<-NA
mat
mat[sample(1:length(mat),omitNr)]<-NA
mat
mat<- matrix(sample(1:100, 5, replace=T), nrow = 3, ncol = 3)
mat
omitNr<-round(length(mat)*0.2)
mat[sample(1:length(mat),omitNr)]<-NA
mat
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
1+1
dt<- sample(1:100,200)
sample(1:100,200)
dt<- sample(1:100,200,replace = T)
dt
matrix(dt,10,20)
sample(100)
sample(1:1000,100)
mat<-matrix(dt,20,5)
mat
matrix(dt,20,5)
length(mat)
length(mat)*0.2
round(length(mat)*0.2)
sample(size )
size<-round(length(mat)*0.2)
sample(size )
indexes<-sample(size )
mat[indexes]<-NA
mat
indexes
mat[indexes]
dt<-sample(1:1000,100)
dt<-sample(1:1000,100)
mat<-matrix(dt,20,5)
mat
size<-round(length(mat)*0.2)
indexes<-sample(size )
indexes
mat[indexes]
indexes
mat[indexes]
mat[indexes]<-NA
mat[indexes]<-NA
mat
indexes<-sample(1:size )
mat[indexes]
size<-round(length(mat)*0.2)
indexes<-sample(1:size )
indexes
mat[indexes]
size<-round(length(mat)*0.2)
indexes<-sample(1:length(mat),size )
mat[indexes]
size<-round(length(mat)*0.2)
size
indexes<-sample(1:length(mat),size )
indexes
mat[indexes]
mat[indexes]<-NA
mat
knitr::opts_chunk$set(echo = TRUE)
matrix(1:20,5,4)
matrix(1:9,3,3)
matrix(1:9,3,3)
data.frame(A=sample(5),
B=sample(5),
C=sample(5))
mat<- matrix(1:9,3,3)
mat[1,3]
mat
data.frame(A=sample(5),
B=sample(5),
C=sample(5),
D= c('A','A','A','D','C'))
dt<-data.frame(A=sample(5),
B=sample(5),
C=sample(5),
D= c('A','A','A','D','C'))
dt$D
dt<-data.frame(A=sample(5),
B=sample(5),
C=sample(5),
D= c('A','A','A','D','C'))
dt$A
?sample
?data.frame
?sample
setwd("C:/Users/salma/OneDrive/Desktop/Ali")
setwd(".")
library(MCMCpack)
source("functions.R")
source("first_Iteration_function.R")
source("second_Iteration_functions.R")
## Generate a random matrix(n,m)
psiLast<-NULL
psiNew <-NULL
mat<-matrix(sample(1:3,15,replace = T),3,5)
#mat
#Omit 20% of matrix enteries
indexSet <- selectRandomIndices(mat)
mat      <- omitEnteries(mat,indexSet)
#***Create Transition Matrix (Psi)***
psiNew<-createTransitionMatrix(mat)
#psiNew
#For any given state (1,2,or 3) there might be 3 different range of probabilities.
chanceMatrix<-obtainChanceMatrix(psiNew)
#chanceMatrix
## First iteration
### Predict proper state for missed data
# 1. Generate a random number
# 2. Use the ***chance matrix*** , to predict the proper state for the missed entery.
# 3. Fill the NAs with proper state
mat<-fillNA_First_Iteration(mat,chanceMatrix,indexSet )
mat
setwd(".")
library(MCMCpack)
source("functions.R")
source("first_Iteration_function.R")
source("second_Iteration_functions.R")
## Generate a random matrix(n,m)
psiLast<-NULL
psiNew <-NULL
mat<-matrix(sample(1:3,15,replace = T),5,3)
#mat
#Omit 20% of matrix enteries
indexSet <- selectRandomIndices(mat)
mat      <- omitEnteries(mat,indexSet)
#***Create Transition Matrix (Psi)***
psiNew<-createTransitionMatrix(mat)
#psiNew
#For any given state (1,2,or 3) there might be 3 different range of probabilities.
chanceMatrix<-obtainChanceMatrix(psiNew)
#chanceMatrix
## First iteration
### Predict proper state for missed data
# 1. Generate a random number
# 2. Use the ***chance matrix*** , to predict the proper state for the missed entery.
# 3. Fill the NAs with proper state
mat<-fillNA_First_Iteration(mat,chanceMatrix,indexSet )
mat
setwd(".")
library(MCMCpack)
source("functions.R")
source("first_Iteration_function.R")
source("second_Iteration_functions.R")
## Generate a random matrix(n,m)
psiLast<-NULL
psiNew <-NULL
mat<-matrix(sample(1:3,15,replace = T),5,3)
mat
indexSet <- selectRandomIndices(mat)
indexSet
# indexSet <- selectRandomIndices(mat)
indexSet <- c(1,7,12)
mat      <- omitEnteries(mat,indexSet)
mat
# indexSet <- selectRandomIndices(mat)
indexSet <- c(4,7,12)
mat      <- omitEnteries(mat,indexSet)
mat
setwd(".")
library(MCMCpack)
source("functions.R")
source("first_Iteration_function.R")
source("second_Iteration_functions.R")
## Generate a random matrix(n,m)
psiLast<-NULL
psiNew <-NULL
mat<-matrix(sample(1:3,15,replace = T),5,3)
mat
#Omit 20% of matrix enteries
# indexSet <- selectRandomIndices(mat)
indexSet <- c(4,7,12)
mat      <- omitEnteries(mat,indexSet)
mat
#***Create Transition Matrix (Psi)***
psiNew<-createTransitionMatrix(mat)
psiNew
#For any given state (1,2,or 3) there might be 3 different range of probabilities.
chanceMatrix<-obtainChanceMatrix(psiNew)
chanceMatrix
## First iteration
### Predict proper state for missed data
# 1. Generate a random number
# 2. Use the ***chance matrix*** , to predict the proper state for the missed entery.
# 3. Fill the NAs with proper state
mat<-fillNA_First_Iteration(mat,chanceMatrix,indexSet )
mat
## Next Iterations
# 1. Update a the Psi
# 2. Compare the new psi with the previous iteration psi
# 3. As long as the 2 last psi matrices are not converged do the following
#
#   3.1. Fill the missed enteries
#
#   3.2. Update the psi
#
#   3.3. Back to 3
psiLast <-psiNew                      # Store the previous Psi matrix
psiNew<-createTransitionMatrix(mat)   # Get a new Psi
counter <- 1
printData(psiNew,psiLast,counter)
# while(!isPSIsConverged(psiNew,psiLast)){     #if it is not cpnverged then continue until convergance
for(i in 1:10){
mat <- fillNA_After_First_Iteration(mat,psiNew, indexSet )
psiLast <- psiNew
psiNew  <- createTransitionMatrix(mat)
counter<- counter+1
printData(psiNew,psiLast,counter)
}
setwd(".")
library(MCMCpack)
source("functions.R")
source("first_Iteration_function.R")
source("second_Iteration_functions.R")
psiLast<-NULL
psiNew <-NULL
mat<-matrix(sample(1:3,15,replace = T),5,3)
mat
# indexSet <- selectRandomIndices(mat)
indexSet <- c(4,7,12)
mat      <- omitEnteries(mat,indexSet)
mat
mat
psiNew<-createTransitionMatrix(mat)
psiNew
chanceMatrix<-obtainChanceMatrix(psiNew)
chanceMatrix
mat<-fillNA_First_Iteration(mat,chanceMatrix,indexSet )
mat
psiLast <-psiNew                      # Store the previous Psi matrix
psiNew<-createTransitionMatrix(mat)   # Get a new Psi
psiNew
psiLast
counter <- 1
printData(psiNew,psiLast,counter)
for(i in 1:10){
mat <- fillNA_After_First_Iteration(mat,psiNew, indexSet )
psiLast <- psiNew
psiNew  <- createTransitionMatrix(mat)
counter<- counter+1
printData(psiNew,psiLast,counter)
}
